% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fct_summarise.R
\name{cross_product_column_names}
\alias{cross_product_column_names}
\title{Cross-product of column names}
\usage{
cross_product_column_names(
  ...,
  always = NULL,
  drop.dupes.within = TRUE,
  drop.dupes.across = TRUE
)
}
\arguments{
\item{...}{any number of arrays, to take the cross-product between.}

\item{always}{an array of values that should always be included in the output
combination.}

\item{drop.dupes.within}{T/F, controls whether duplicated values within each
output set are discarded. For example: \verb{(a,b,c,a,b)} becomes \verb{(a,b,c)}.
Note: dplyr::group_by requires no duplicates so turning this off
may produce errors if the output is used for summarizing results.
Defaults to TRUE.}

\item{drop.dupes.across}{T/F, control whether duplicated sets of values
across the output are discarded. For example: \code{list(c(a,b,c), c(a,c,b))}
will only output \code{c(a,b,c)}.
Defaults to TRUE.}
}
\value{
A list of arrays produced by taking the cross-products of each input
group, appending the always inputs, and tidying by removing duplication
where applicable.
}
\description{
Creates the cross-products of its inputs. Designed for receiving column names
and creating combinations to group-by in analysis. For example if we want
every pairwise combination of demographic columns then store the names of
the demographic columns in an array called \code{demographic_columns} and call:
\code{cross_product_column_names(demographic_columns, demographic_columns)}
}
\examples{
# setup
grp1 = c("d","e")
grp2 = c("f","g")
grp3 = c("a","b","c")
# output
cross_product_column_names(grp1, grp2, always = grp3)
cross_product_column_names(grp3, grp3)
cross_product_column_names(grp3, grp3, drop.dupes.across = FALSE)
cross_product_column_names(grp3, grp3, drop.dupes.within = FALSE)

}
